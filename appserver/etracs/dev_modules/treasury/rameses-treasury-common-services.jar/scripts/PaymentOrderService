import com.rameses.annotations.*;
import com.rameses.util.*;

class PaymentOrderService {

	@DataContext("paymentorder") 
	def pmtOrderEm; 
	
	@DataContext("paymentorder_type") 
	def poTypeEm;  

	@Service("DateService")
	def dateSvc;

	@Service(dynamic=true)
	def dynSvc;

	@Service
	def self;

	@Env
	def env;

	@ProxyMethod
	public def getBarcodePrefix( def conn ) {
		// implementation to this method 
		// is done by an Interceptor and 
		// barcodeid must be overidden  
		return [ barcodeid: null ]; 
	} 

	@ProxyMethod
	public def getRootOrg() {
		// implementation to this method 
		// is done by an Interceptor and 
		// the result must be overidden  
		return [:]; 
	} 

	@ProxyMethod
	public def initData( def param ) {
		def org = self.getRootOrg(); 
		def keygen = KeyGen.generateAlphanumKey( "", 7 ); 
		if ( org?.objid ) {
			param.objid = org.objid.toString().replace('-','') + keygen;
		} 
		else {
			param.objid = keygen;
		}

		param.txndate = dateSvc.getServerDate();

		def cal = Calendar.instance;
		cal.setTime( param.txndate );
		cal.add( Calendar.HOUR, 24 );
		param.expirydate = new java.sql.Timestamp( cal.getTimeInMillis() );
		param.issuedby = [objid:env.USERID, name:env.FULLNAME];

		if ( param._origin ) {
			if ( param.issuedby.objid == null ) 
				param.issuedby.objid = param._origin;

			if ( param.issuedby.name == null ) 
				param.issuedby.name = param._origin;
		}

		return param;
	}

	@ProxyMethod
	public def create( def o ) {
		if (!o.connection) throw new Exception("connection is required");
		if (!o.typeid) throw new Exception("paymentorder typeid is required");
		
		if (!o.paidby) throw new Exception("Paid by is required");
		if (!o.paidbyaddress) throw new Exception("Paid by address is required");
		if (!o.items && !o.params) throw new Exception("items or params is required");

		if (o.params) {
			if (!o.refno) throw new Exception("refno is required when params is specified");
		}

		o.type = poTypeEm.find([ objid: o.typeid ]).first();
		if ( !o.type ) 
			throw new Exception("'"+ o.typeid +"' does not exist in paymentorder_type");

		o = self.initData( o );

		if ( o.items ) { 
			//validate items
			o.items.eachWithIndex{ oo,idx-> 
				if ( !oo.item?.objid ) throw new Exception("items["+ idx +"].item.objid  property is required");
				if ( !oo.item?.code ) throw new Exception("items["+ idx +"].item.code  property is required");
				if ( !oo.item?.title ) throw new Exception("items["+ idx +"].item.title  property is required");
				if ( !oo.item?.fund?.objid ) throw new Exception("items["+ idx +"].item.fund.objid  property is required");
				if ( oo.amount == null ) throw new Exception("items["+ idx +"].amount  property is required");
			}
			o.amount =  NumberUtil.round( o.items.sum{( it.amount ? it.amount : 0.0 )} );
		} 

		if (o.amount == null) 
			throw new Exception("amount is required");
		if (o.amount <= 0.0) 
			throw new Exception("amount must be greater than zero");

		pmtOrderEm.create( o );

		def bc = self.getBarcodePrefix( o.connection ); 
		o.barcode = bc?.barcodeid +":"+ o.objid; 
		return o;
	}

	@ProxyMethod
	public def getBilling(o) {
		def po = pmtOrderEm.find( [objid: o.refno ]).first();
		if ( !po ) throw new Exception("Payment Order " + o.refno + " not found");
		
		def result = [:];
		result.txndate = po.txndate; 
		result.expirydate = po.expirydate; 
		result.payer = po.payer;
		result.paidby = po.paidby;
		result.paidbyaddress = po.paidbyaddress;
		result.remarks = po.particulars;
		result.amount = po.amount;
		result._paymentorderid = po.objid;
		result.type = po.type;
		
		if( po.items ) {
			result.items = [];
			po.items.each {
				def v = [:];
				v.item = [objid: it.item.objid, code:it.item.code, title: it.item.title, fund: it.item.fund ];
				v.amount = it.amount;
				v.remarks = it.remarks;
				result.items << v;
			} 	
			result.amount = NumberUtil.round( result.items.sum{it.amount} );
		}	

		result.refno = po.refno; 
		result.params = po.params;
		result.email = po.email;
		result.mobileno = po.mobileno;
		return result;
	}

	@ProxyMethod
	public void postPayment( po ) {
		pmtOrderEm.find([ objid: po.objid ]).delete();
	}

	@ProxyMethod
	public void verifyCheckSum( objid, checksum ) {
		def newchecksum = buildCheckSum( objid ); 
		if ( newchecksum != checksum ) {
			println '\n\nnewchecksum: '+ newchecksum +', oldchecksum: '+ checksum; 
			throw new Exception("Invalid Payment Order "+ po.objid);
		}
	}

	@ProxyMethod(local=true)
	public def buildCheckSum( objid ) {
		def po = pmtOrderEm.find([ objid: objid ]).select('objid,amount,email').first(); 
		if ( !po ) throw new Exception("'"+ objid +"' payment order not found");

		def buff = new StringBuilder();
		buff.append( po.objid ); 
		buff.append( new java.text.DecimalFormat('0.00').format( po.amount ));
		buff.append( po.email.toString()); 
		return com.rameses.util.Encoder.MD5.encode( buff.toString(), po.objid);
	}


	@ProxyMethod
	public def verify( objid, amount ) {
		if ( !objid ) throw new Exception("objid  argument is required");
		if ( amount == null ) throw new Exception("amount  argument is required");

		def po = pmtOrderEm.find([ objid: objid ]).select('objid,amount').first(); 
		if ( !po ) throw new Exception("'"+ objid +"' payment order not found");

		if ( amount != po.amount ) 
			throw new Exception("Payment Order amount mismatched"); 
	} 
}